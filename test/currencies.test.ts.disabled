import { expect } from "chai";
import * as fc from "fast-check";

import * as monetary from "../src/monetary";

describe("currencies", () => {
  describe("BTC", () => {
    it("should have the correct amount of decimals", () => {
      expect(monetary.BTC.decimals).to.eq(8);
    });

    it("should have the correct name", () => {
    });
  });

  describe("ETH", () => {
    it("should have the correct amount of decimals", () => {
      expect(monetary.ETH.decimals).to.eq(18);
    });

    it("should have the correct name", () => {
      expect(monetary.ETH.name).to.eq("Ethereum");
    });
  });

  describe("ERC20", () => {
    const dai = new monetary.ERC20("Dai", "0x", 18);
    const comp = new monetary.ERC20("Compound", "0x", 12);

    it("should have customizable decimals", () => {
      expect(dai.decimals).to.eq(18);
      expect(comp.decimals).to.eq(12);
    });

    it("should have customizable name", () => {
      expect(dai.name).to.eq("Dai");
      expect(comp.name).to.eq("Compound");
    });
  });
});

  type toBTCAmount = "toSatoshi" | "toMSatoshi" | "toBTC";

  describe("BTCAmount", () => {
    const cases: [
      (amount: BigSource) => monetary.BTCAmount,
      toBTCAmount,
      number
    ][] = [
      [monetary.BTCAmount.fromSatoshi, "toSatoshi", 100_000_000],
      [monetary.BTCAmount.fromMSatoshi, "toMSatoshi", 100_000],
      [monetary.BTCAmount.fromBTC, "toBTC", 1],
    ];
    cases.forEach(([from, toName, decimalMul]) => {
      describe(from.name, () => {
        it("should be symmetric with toSatoshi", () => {
          fc.assert(
            fc.property(
              fc.integer().map((v) => new Big(v)),
              (rawAmount) => {
                const amount = from(rawAmount);
                // fromSatoshi -> toSatoshi
                expect(amount[toName]().toString()).to.eq(
                  rawAmount.toString()
                );
              }
            )
          );
        });

        it("should be convertible to BTC", () => {
          fc.assert(
            fc.property(
              fc.integer().map((v) => new Big(v)),
              (rawAmount) => {
                const amount = from(rawAmount);
                expect(amount.toBTC().toString()).to.eq(
                  rawAmount.div(decimalMul).toString()
                );
              }
            )
          );
        });
      });
    });
  });

  type toETHAmount = "toWei" | "toGWei" | "toEther";

  describe("ETHAmount", () => {
    const cases: [
      (amount: BigSource) => monetary.ETHAmount,
      toETHAmount,
      number
    ][] = [
      [monetary.ETHAmount.fromWei, "toWei", Math.pow(10, 18)],
      [monetary.ETHAmount.fromGWei, "toGWei", Math.pow(10, 9)],
      [monetary.ETHAmount.fromEther, "toEther", 1],
    ];
    cases.forEach(([from, toName, decimalMul]) => {
      describe(from.name, () => {
        it("should be symmetric with toWei", () => {
          fc.assert(
            fc.property(
              fc.integer().map((v) => new Big(v)),
              (rawAmount) => {
                const amount = from(rawAmount);
                // fromWei -> toWei
                expect(amount[toName]().toString()).to.eq(
                  rawAmount.toString()
                );
              }
            )
          );
        });

        it("should be convertible to Ether", () => {
          fc.assert(
            fc.property(
              fc.integer().map((v) => new Big(v)),
              (rawAmount) => {
                const amount = from(rawAmount);
                expect(amount.toEther().toString()).to.eq(
                  rawAmount.div(decimalMul).toString()
                );
              }
            )
          );
        });
      });
    });
  });

  describe("ERC20Amount", () => {
    describe("constructor", () => {
      it("should delegate to parent", () => {
        const rawAmount = new Big(10);
        const amount = new monetary.ERC20Amount(
          DummyERCT,
          rawAmount,
          0
        );
        const expected = rawAmount
          .mul(new Big(10).pow(DummyERCT.decimals))
          .toString();
        expect(amount.toString()).to.eq(expected);
      });
    });

    type amountOp = "add" | "sub";

    describe("arithmetic", () => {
      (["add", "sub"] as Array<amountOp>).forEach((op) => {
        describe(op, () => {
          it(`should ${op} tokens`, () => {
            const dai = new monetary.ERC20("Dai", "0x");
            const amountA = new monetary.ERC20Amount(dai, 30);
            const amountB = new monetary.ERC20Amount(dai, 10);
            const added = amountA[op](amountB);
            const expected = op === "add" ? "40" : "20";
            expect(added.toBig().toString()).to.eq(expected);
          });

          it("should fail with different currencies", () => {
            const amountA = new monetary.ERC20Amount(
              new monetary.ERC20("Dai", "0x"),
              30
            );
            const amountB = new monetary.ERC20Amount(
              new monetary.ERC20("Compound", "0x"),
              10
            );
            expect(() => amountA[op](amountB)).to.throw(
              `cannot ${op}`
            );
          });
        });
      });
    });
  });
